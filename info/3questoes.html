<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulado Técnico: Hardware e Drivers de Dispositivos</title>
    <style>
        :root {
            --bg-color: #fcfcfc;
            --text-color: #2d3436;
            --primary-color: #0984e3;
            --secondary-color: #636e72;
            --correct-color: #27ae60;
            --wrong-color: #d63031;
            --border-color: #dfe6e9;
            --card-bg: #ffffff;
            --max-width: 850px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Georgia, serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            padding: 40px 20px;
        }

        header {
            max-width: var(--max-width);
            margin: 0 auto 50px auto;
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            color: #1a1a1a;
        }

        header p {
            color: var(--secondary-color);
            font-style: italic;
        }

        main {
            max-width: var(--max-width);
            margin: 0 auto;
        }

        .question-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
        }

        .question-text {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: block;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option-label {
            display: flex;
            align-items: flex-start;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option-label:hover {
            background-color: #f1f2f6;
            border-color: var(--primary-color);
        }

        .option-label input {
            margin-right: 15px;
            margin-top: 6px;
        }

        .option-label.selected {
            background-color: #e3f2fd;
            border-color: var(--primary-color);
        }

        /* Results Styles */
        .feedback-section {
            display: none;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .result-status {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .status-correct { color: var(--correct-color); }
        .status-wrong { color: var(--wrong-color); }

        .explanation-box {
            background-color: #f8f9fa;
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            font-size: 0.95rem;
            color: #444;
        }

        .btn-submit {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 40px auto;
            padding: 15px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn-submit:hover {
            background-color: #0771c1;
        }

        .score-banner {
            display: none;
            text-align: center;
            background: #2d3436;
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 40px;
        }

        .score-banner h2 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        footer {
            text-align: center;
            margin-top: 60px;
            color: var(--secondary-color);
            font-size: 0.9rem;
        }

        @media (max-width: 600px) {
            body { padding: 20px 15px; }
            .question-card { padding: 20px; }
        }
    </style>
</head>
<body>

<header>
    <h1>Simulado: Drivers de Dispositivos</h1>
    <p>Perfil: Fundação CEFETMINAS | Cargo: Professor EBTT Informática</p>
</header>

<main id="quiz-container">
    <div id="score-banner" class="score-banner">
        <h2>Pontuação Final: <span id="final-score">0</span>/10</h2>
        <p id="score-message"></p>
    </div>

    <div id="questions-list">
        <!-- Questions injected here -->
    </div>

    <button id="submit-quiz" class="btn-submit">Finalizar Simulado</button>
</main>

<footer>
    <p>© Simulado de Alto Nível - Preparação para Institutos Federais</p>
</footer>

<script>
    const quizData = [
        {
            id: 1,
            question: "QUESTÃO 01: Andrew S. Tanenbaum estabelece uma distinção fundamental na arquitetura de drivers baseada na granularidade de acesso. No Linux, essa distinção se manifesta na categorização entre dispositivos de bloco (block devices) e dispositivos de caractere (character devices). Analise as assertivas:\n\nI. A principal característica do dispositivo de bloco é suportar operações de busca (seek) aleatória.\nII. Interfaces de rede, embora transmitam sequencialmente, possuem categoria própria no Linux (não são estritamente dispositivos de caractere em /dev).\nIII. Drivers de bloco utilizam obrigatoriamente o cache de páginas do kernel, enquanto drivers de caractere interagem diretamente com o espaço de usuário ou buffers simples.",
            options: [
                "A) Apenas a assertiva I é tecnicamente verdadeira.",
                "B) As assertivas I e II são verdadeiras.",
                "C) As assertivas I e III são verdadeiras.",
                "D) Apenas a assertiva III é verdadeira.",
                "E) As assertivas I, II e III são verdadeiras."
            ],
            correct: 4,
            explanation: "<b>Justificativa:</b> Conforme Tanenbaum e a arquitetura do Kernel Linux, dispositivos de bloco são endereçáveis e permitem seek aleatório (I). Interfaces de rede são uma exceção tratada via subsistema de sockets e não possuem arquivos em /dev (II). O subsistema de bloco é otimizado pelo buffer/page cache, enquanto o de caractere costuma ser direto ou com filas simples (III)."
        },
        {
            id: 2,
            question: "QUESTÃO 02: Considere um cenário onde um driver de disco causa 'congelamentos' momentâneos da CPU durante operações intensas. Com base na teoria de barramentos e DMA, qual explica tecnicamente o fenômeno?",
            options: [
                "A) O driver configurou o modo Cycle Stealing, forçando wait states a cada byte.",
                "B) O dispositivo opera em modo Burst (Rajada), detendo o controle exclusivo do barramento e impedindo a CPU de acessar a RAM.",
                "C) Ocorreu um conflito de interrupções causado pelo modo Transparent DMA.",
                "D) O driver falhou em alocar buffers contíguos, saturando a arbitragem a cada página de 4KB.",
                "E) O mecanismo de Bus Mastering foi desativado, revertendo para PIO."
            ],
            correct: 1,
            explanation: "<b>Justificativa:</b> No modo Burst, o controlador de DMA detém o barramento até completar a transferência. Se a CPU precisar buscar uma instrução na memória (cache miss) ou ler dados durante esse período, ela ficará travada (wait state) até que o DMA libere o barramento."
        },
        {
            id: 3,
            question: "QUESTÃO 03: No desenvolvimento de drivers, o tratamento de interrupções é dividido em Top Half e Bottom Half. Qual alternativa descreve corretamente a distribuição de responsabilidades?",
            options: [
                "A) O Top Half realiza a cópia e processa cabeçalhos TCP/IP; o Bottom Half notifica a aplicação.",
                "B) O Top Half reconhece a interrupção (ACK) e agenda o Bottom Half; o Bottom Half processa os dados com interrupções habilitadas.",
                "C) O Top Half pode dormir (sleep) e o Bottom Half é atômico.",
                "D) A distinção é exclusiva para sistemas multiprocessados (SMP).",
                "E) O uso de Workqueues é obrigatório para o Top Half."
            ],
            correct: 1,
            explanation: "<b>Justificativa:</b> O Top Half deve ser o mais rápido possível (ACK ao hardware) para evitar perda de novas interrupções. O processamento pesado (Bottom Half) é feito depois, permitindo que novas interrupções ocorram durante sua execução."
        },
        {
            id: 4,
            question: "QUESTÃO 04: A arquitetura Windows NT implementa uma camada entre o kernel e o hardware para garantir portabilidade. Qual é essa camada?",
            options: [
                "A) Camada de Compatibilidade de Driver (DCL).",
                "B) Executive Services.",
                "C) Microkernel.",
                "D) Hardware Abstraction Layer (HAL).",
                "E) I/O Manager."
            ],
            correct: 3,
            explanation: "<b>Justificativa:</b> A HAL (Hardware Abstraction Layer) isola o Kernel de detalhes específicos do chipset da placa-mãe, como controladores de interrupção e temporizadores, provendo uma API uniforme."
        },
        {
            id: 5,
            question: "QUESTÃO 05: Considere um driver que mantém uma variável global para contar bytes. Se não for reentrante, qual a consequência mais provável em alta carga?",
            options: [
                "A) Deadlock imediato por bloqueio de barramento.",
                "B) Condição de Corrida (Race Condition); solução envolve Spinlocks ou Mutexes.",
                "C) O sistema impedirá o carregamento do módulo.",
                "D) A reentrância é garantida automaticamente pelo escalonador.",
                "E) O problema afeta apenas drivers de bloco."
            ],
            correct: 1,
            explanation: "<b>Justificativa:</b> Variáveis globais acessadas por múltiplos fluxos de execução (ou interrupções) sem proteção sofrem de Race Conditions. Spinlocks são usados em contextos atômicos e Mutexes quando o driver pode dormir."
        },
        {
            id: 6,
            question: "QUESTÃO 06: Qual a principal vantagem do Double Buffering em relação ao buffering simples?",
            options: [
                "A) Elimina a necessidade de interrupções de hardware.",
                "B) Permite que a transferência para um buffer ocorra simultaneamente ao processamento do outro buffer pela CPU.",
                "C) Reduz a latência inicial pela metade.",
                "D) Serve primariamente como backup em caso de corrupção de dados.",
                "E) Permite acesso direto à memória virtual do usuário sem cópias."
            ],
            correct: 1,
            explanation: "<b>Justificativa:</b> O Double Buffering permite o paralelismo real: enquanto o hardware preenche um buffer, a CPU processa o outro que já foi preenchido anteriormente."
        },
        {
            id: 7,
            question: "QUESTÃO 07: Em qual camada do subsistema de E/S reside a função de 'Nomeação Independente de Dispositivo'?",
            options: [
                "A) Na camada de Hardware.",
                "B) No próprio Driver de Dispositivo.",
                "C) No Software de E/S Independente de Dispositivo.",
                "D) Nas bibliotecas de Espaço de Usuário.",
                "E) No Tratador de Interrupções."
            ],
            correct: 2,
            explanation: "<b>Justificativa:</b> De acordo com a arquitetura de camadas de Tanenbaum, a nomeação uniforme e o mapeamento de nomes simbólicos para drivers específicos são tarefas do software independente de dispositivo."
        },
        {
            id: 8,
            question: "QUESTÃO 08: Na E/S Mapeada em Memória, qual o desafio crítico relacionado ao cache da CPU?",
            options: [
                "A) O cache pode armazenar valores antigos dos registradores; a solução é marcar as páginas como 'uncacheable'.",
                "B) Consome ciclos do controlador de DMA.",
                "C) Cria vulnerabilidades onde qualquer usuário pode escrever na memória de vídeo.",
                "D) É incompatível com sistemas de memória virtual.",
                "E) A memória RAM é volátil, registradores não."
            ],
            correct: 0,
            explanation: "<b>Justificativa:</b> Registradores de hardware mudam independentemente da CPU. Se a CPU ler do cache, verá o valor antigo. Desativar o cache para essas páginas garante que a CPU sempre acesse o hardware real."
        },
        {
            id: 9,
            question: "QUESTÃO 09: Qual syscall é projetada para operações de controle 'fora de banda' (como ejetar mídia ou definir volume)?",
            options: [
                "A) fcntl.",
                "B) mmap.",
                "C) ioctl (Input/Output Control).",
                "D) sysfs.",
                "E) socket."
            ],
            correct: 2,
            explanation: "<b>Justificativa:</b> O 'ioctl' é o mecanismo universal no UNIX para enviar comandos que não se encaixam no fluxo tradicional de leitura e escrita de bytes."
        },
        {
            id: 10,
            question: "QUESTÃO 10: Qual a implicação da abstração LBA (Logical Block Addressing) para os algoritmos de escalonamento de disco?",
            options: [
                "A) Não precisa mais de ordenação, pois o acesso é uniforme.",
                "B) O SO assume que LBAs adjacentes são fisicamente próximos, mantendo a eficácia de algoritmos como SCAN.",
                "C) Impede o uso de algoritmos no nível do SO.",
                "D) O driver deve remapear manualmente para CHS antes de enviar.",
                "E) É usada apenas em SSDs."
            ],
            correct: 1,
            explanation: "<b>Justificativa:</b> Mesmo sem saber a geometria física exata (Cilindro/Cabeça/Setor), o LBA mantém uma correlação espacial. O SO ordena as requisições para minimizar o movimento do braço mecânico baseando-se na proximidade dos números de bloco."
        }
    ];

    const listElement = document.getElementById('questions-list');
    const submitBtn = document.getElementById('submit-quiz');
    const scoreBanner = document.getElementById('score-banner');
    const finalScoreTxt = document.getElementById('final-score');
    const scoreMessageTxt = document.getElementById('score-message');

    function renderQuiz() {
        quizData.forEach((q, qIndex) => {
            const card = document.createElement('div');
            card.className = 'question-card';
            card.id = `q-card-${qIndex}`;

            const qText = document.createElement('span');
            qText.className = 'question-text';
            qText.innerText = q.question;
            card.appendChild(qText);

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'options-container';

            q.options.forEach((opt, oIndex) => {
                const label = document.createElement('label');
                label.className = 'option-label';
                label.innerHTML = `<input type="radio" name="question-${qIndex}" value="${oIndex}"> ${opt}`;
                
                label.addEventListener('click', () => {
                    document.querySelectorAll(`[name="question-${qIndex}"]`).forEach(input => {
                        input.parentElement.classList.remove('selected');
                    });
                    label.classList.add('selected');
                });

                optionsDiv.appendChild(label);
            });

            card.appendChild(optionsDiv);

            // Hidden feedback section
            const feedback = document.createElement('div');
            feedback.className = 'feedback-section';
            feedback.id = `feedback-${qIndex}`;
            feedback.innerHTML = `
                <div class="result-status" id="status-${qIndex}"></div>
                <div class="explanation-box">${q.explanation}</div>
            `;
            card.appendChild(feedback);

            listElement.appendChild(card);
        });
    }

    function evaluateQuiz() {
        let score = 0;
        let unanswered = false;

        quizData.forEach((q, qIndex) => {
            const selected = document.querySelector(`input[name="question-${qIndex}"]:checked`);
            const feedback = document.getElementById(`feedback-${qIndex}`);
            const status = document.getElementById(`status-${qIndex}`);
            
            if (!selected) {
                unanswered = true;
            }

            const isCorrect = selected && parseInt(selected.value) === q.correct;
            
            if (isCorrect) score++;

            // Reveal feedback
            feedback.style.display = 'block';
            if (isCorrect) {
                status.innerText = "✓ Resposta Correta";
                status.className = "result-status status-correct";
            } else {
                status.innerText = `✗ Resposta Incorreta (Gabarito: ${q.options[q.correct].substring(0,2)})`;
                status.className = "result-status status-wrong";
            }

            // Disable all inputs
            document.querySelectorAll(`input[name="question-${qIndex}"]`).forEach(input => {
                input.disabled = true;
            });
        });

        // Show overall score
        scoreBanner.style.display = 'block';
        finalScoreTxt.innerText = score;
        
        if (score >= 8) scoreMessageTxt.innerText = "Excelente desempenho! Nível de aprovação para concursos EBTT.";
        else if (score >= 6) scoreMessageTxt.innerText = "Bom desempenho, mas revise os pontos onde houve dúvida.";
        else scoreMessageTxt.innerText = "Continue estudando. A bibliografia de Tanenbaum e Stallings é essencial para esta banca.";

        submitBtn.style.display = 'none';
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    submitBtn.addEventListener('click', evaluateQuiz);

    window.onload = renderQuiz;
</script>

</body>
</html>