<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulado de Hardware - Professor EBTT - FCM</title>
    <style>
        :root {
            --bg-color: #fdfdfd;
            --container-bg: #ffffff;
            --text-main: #2c3e50;
            --text-muted: #546e7a;
            --accent: #2980b9;
            --correct: #27ae60;
            --incorrect: #c0392b;
            --border: #e0e0e0;
            --resolution-bg: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        .quiz-container {
            max-width: 850px;
            width: 100%;
            background: var(--container-bg);
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            border: 1px solid var(--border);
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 20px;
        }

        header h1 {
            font-size: 1.8rem;
            margin: 0;
            color: var(--accent);
        }

        header p {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-top: 10px;
        }

        .question-block {
            margin-bottom: 50px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border);
        }

        .question-text {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 20px;
            display: block;
        }

        .options-list {
            list-style: none;
            padding: 0;
        }

        .option-item {
            margin-bottom: 12px;
            padding: 12px 15px;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .option-item:hover {
            background-color: #f1f7fc;
            border-color: var(--accent);
        }

        .option-item input {
            margin-right: 15px;
            transform: scale(1.2);
            cursor: pointer;
        }

        .option-item.selected {
            border-color: var(--accent);
            background-color: #e3f2fd;
        }

        /* Classes de Correção */
        .option-item.correct {
            background-color: #d4edda !important;
            border-color: var(--correct) !important;
            color: #155724;
        }

        .option-item.wrong {
            background-color: #f8d7da !important;
            border-color: var(--incorrect) !important;
            color: #721c24;
        }

        .resolution-box {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background-color: var(--resolution-bg);
            border-left: 5px solid var(--accent);
            border-radius: 4px;
            font-size: 0.95rem;
        }

        .resolution-box h4 {
            margin-top: 0;
            color: var(--accent);
            font-size: 1rem;
            text-transform: uppercase;
        }

        #submit-btn {
            display: block;
            width: 100%;
            padding: 18px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 20px;
        }

        #submit-btn:hover {
            background-color: #1a5276;
        }

        #results-summary {
            display: none;
            text-align: center;
            padding: 30px;
            margin-bottom: 30px;
            background: #e3f2fd;
            border-radius: 8px;
            border: 1px solid var(--accent);
        }

        #results-summary h2 {
            margin: 0;
            color: var(--accent);
        }

        .score-box {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 10px 0;
        }

        @media (max-width: 600px) {
            .quiz-container {
                padding: 20px;
            }
            header h1 {
                font-size: 1.4rem;
            }
        }
    </style>
</head>
<body>

<div class="quiz-container">
    <header>
        <h1>Simulado de Hardware: Conceitos, Componentes e Periféricos</h1>
        <p>Perfil da Banca: Fundação CEFETMINAS | Cargo: Professor de Informática EBTT</p>
    </header>

    <div id="results-summary">
        <h2>Resultado do Simulado</h2>
        <div class="score-box" id="score-display">0/10</div>
        <p id="feedback-text">Confira as resoluções detalhadas abaixo para consolidar seu aprendizado.</p>
    </div>

    <form id="quiz-form">
        <!-- Questões serão injetadas via JavaScript -->
        <div id="questions-wrapper"></div>
        
        <button type="button" id="submit-btn" onclick="calculateResults()">Finalizar e Ver Resoluções</button>
    </form>
</div>

<script>
    const questions = [
        {
            id: 1,
            text: "Questão 01 - O pipelining é uma técnica de implementação fundamental para o aumento de desempenho em processadores modernos, permitindo a sobreposição temporal das fases de execução das instruções. Considere um processador com um pipeline de 5 estágios: Busca (IF), Decodificação (ID), Execução (EX), Memória (MEM) e Escrita (WB). A respeito dos hazards (conflitos) que podem degradar o desempenho ideal deste pipeline, analise as afirmativas a seguir:\n\nI. O conflito estrutural (structural hazard) ocorre quando o hardware não possui recursos suficientes para suportar todas as combinações possíveis de instruções simultâneas, como a tentativa de buscar uma instrução na memória e acessar um dado (Load/Store) no mesmo ciclo, em uma arquitetura de memória unificada (Von Neumann puro sem caches separadas).\nII. O forwarding (ou bypassing) é uma técnica de hardware utilizada para mitigar conflitos de dados (data hazards) do tipo RAW (Read After Write), permitindo que um dado calculado na ULA seja utilizado pela instrução seguinte antes mesmo de ser escrito no banco de registradores.\nIII. Os conflitos de controle (control hazards), decorrentes de instruções de desvio (branches), são resolvidos exclusivamente através da inserção de instruções NOP (No Operation) pelo compilador, não havendo mecanismos de hardware capazes de prever o fluxo de execução.\n\nEstão CORRETAS as afirmativas:",
            options: [
                "Apenas I.",
                "Apenas II.",
                "Apenas I e II.",
                "Apenas II e III.",
                "I, II e III."
            ],
            answer: 2, // Letra C (Index 2)
            resolution: "Gabarito: C. A afirmativa I está correta ao descrever o hazard estrutural. A II está correta ao descrever o forwarding como mecanismo de mitigação de hazards de dados. A III está incorreta porque o hardware possui mecanismos de Predição de Desvio (Branch Prediction), não sendo uma tarefa exclusiva do compilador."
        },
        {
            id: 2,
            text: "Questão 02 - A hierarquia de memória explora o princípio da localidade para oferecer ao sistema uma memória que parece ter a velocidade da cache e o tamanho do disco. Sobre as tecnologias empregadas nessa hierarquia, assinale a alternativa INCORRETA:",
            options: [
                "As memórias Cache (L1, L2, L3) são tipicamente construídas com tecnologia SRAM (Static RAM), que não requer circuitos de refresh periódicos.",
                "A Memória Principal é geralmente composta por módulos de DRAM (Dynamic RAM), onde cada bit é armazenado em um capacitor controlado por um transistor.",
                "Em um mapeamento de cache associativo por conjunto (Set-Associative), um bloco da memória principal pode ser armazenado em qualquer linha de um conjunto específico.",
                "O princípio da localidade espacial justifica a transferência de blocos (linhas de cache) inteiros da memória principal para a cache.",
                "A memória Cache L1 é invariavelmente mais lenta que a Cache L2, pois sofre maior interferência eletromagnética devido à proximidade com o núcleo."
            ],
            answer: 4, // Letra E
            resolution: "Gabarito: E (Incorreta). A L1 é a memória mais rápida da hierarquia de cache, operando na mesma frequência do núcleo do processador. A justificativa de interferência eletromagnética é tecnicamente descabida."
        },
        {
            id: 3,
            text: "Questão 03 - Um laboratório do IF necessita de um servidor que suporte a falha simultânea de até 2 discos rígidos sem perda de dados, mantendo o maior espaço de armazenamento útil possível com 4 discos de 4 TB cada. Qual configuração de RAID deve ser adotada?",
            options: [
                "RAID 0.",
                "RAID 1 (utilizando os 4 discos como um único espelho).",
                "RAID 5.",
                "RAID 6.",
                "RAID 10 (1+0)."
            ],
            answer: 3, // Letra D
            resolution: "Gabarito: D. O RAID 6 utiliza dupla paridade distribuída e garante a integridade dos dados mesmo com a falha de quaisquer 2 discos simultâneos. O RAID 10 pode falhar se dois discos do mesmo espelho quebrarem."
        },
        {
            id: 4,
            text: "Questão 04 - Sobre a comparação entre SSDs SATA e SSDs NVMe, assinale a alternativa correta:",
            options: [
                "O protocolo AHCI foi otimizado para memórias Flash, permitindo filas de até 64 mil comandos.",
                "O formato M.2 é exclusivo para drives NVMe; portanto, todo SSD M.2 trafega dados via PCI Express.",
                "O protocolo NVMe foi projetado para operar sobre o barramento PCI Express, eliminando gargalos legados do AHCI e reduzindo a latência.",
                "SSDs NVMe Gen4 não são retrocompatíveis com slots M.2 PCIe 3.0.",
                "A vantagem do SSD SATA sobre o NVMe reside na sua capacidade de realizar Garbage Collection em hardware."
            ],
            answer: 2, // Letra C
            resolution: "Gabarito: C. NVMe foi desenhado para memória não volátil de alta velocidade sobre o barramento PCIe, suportando múltiplas filas de comandos, ao contrário do AHCI (SATA) que foi criado para HDDs."
        },
        {
            id: 5,
            text: "Questão 05 - Nos sistemas modernos baseados em processadores Intel Core e AMD Ryzen, observa-se que:",
            options: [
                "A Ponte Norte (Northbridge) foi integrada ao processador, incorporando o controlador de memória e linhas PCIe para vídeo.",
                "A Ponte Sul (Southbridge) assumiu o controle da memória RAM DDR4/DDR5 para liberar o processador.",
                "O barramento FSB (Front Side Bus) teve sua frequência triplicada para suportar a comunicação com a Ponte Norte dedicada.",
                "O BIOS foi completamente removido, sendo substituído por um microcontrolador que carrega o SO da nuvem.",
                "Os slots PCI Express são gerenciados exclusivamente pelo PCH, sem conexão direta com o processador."
            ],
            answer: 0, // Letra A
            resolution: "Gabarito: A. A arquitetura moderna integrou as funções da Ponte Norte (controlador de memória e PCIe principal) no die do processador (System on Chip ou Uncore), deixando apenas o PCH (antiga Ponte Sul) na placa-mãe."
        },
        {
            id: 6,
            text: "Questão 06 - Uma característica distintiva dos módulos DDR5 em relação aos seus antecessores (DDR3/DDR4) é:",
            options: [
                "A mudança da tensão de operação para 1.5V para sustentar altas frequências.",
                "A integração do circuito de gerenciamento de energia (PMIC) no próprio módulo de memória (DIMM).",
                "A redução da latência CAS (CL) para valores nominais inferiores a 10 ciclos.",
                "A utilização de um único canal de dados de 128 bits por módulo.",
                "A incompatibilidade lógica com códigos de correção de erro (ECC), removida para consumidores finais."
            ],
            answer: 1, // Letra B
            resolution: "Gabarito: B. Na DDR5, a regulação de tensão saiu da placa-mãe e foi para o módulo (DIMM) através do chip PMIC, garantindo maior eficiência energética e estabilidade de sinal."
        },
        {
            id: 7,
            text: "Questão 07 - Assinale a alternativa que ordena corretamente as etapas do ciclo de impressão a laser (eletrofotográfico):",
            options: [
                "Revelação -> Carregamento -> Exposição -> Fusão -> Transferência.",
                "Carregamento -> Exposição -> Revelação -> Transferência -> Fusão.",
                "Exposição -> Carregamento -> Transferência -> Revelação -> Fusão.",
                "Limpeza -> Fusão -> Exposição -> Revelação -> Transferência.",
                "Carregamento -> Revelação -> Exposição -> Fusão -> Transferência."
            ],
            answer: 1, // Letra B
            resolution: "Gabarito: B. A sequência lógica é: Carregamento (carga no cilindro), Exposição (laser cria imagem latente), Revelação (toner adere à imagem), Transferência (toner vai para o papel) e Fusão (calor fixa o toner)."
        },
        {
            id: 8,
            text: "Questão 08 - Se aplicarmos os sinais A=1 e B=1 em uma porta NAND, qual será a saída? E qual o valor hexadecimal de 11011011?",
            options: [
                "Saída 0; Hex DB.",
                "Saída 1; Hex DB.",
                "Saída 0; Hex CB.",
                "Saída 1; Hex DA.",
                "Saída 0; Hex EB."
            ],
            answer: 0, // Letra A
            resolution: "Gabarito: A. NAND(1,1) resulta em NOT(AND(1,1)) = NOT(1) = 0. O binário 1101 (13 em decimal) é D e 1011 (11 em decimal) é B. Logo, DB."
        },
        {
            id: 9,
            text: "Questão 09 - Sobre as características de largura de banda e codificação do PCI Express (PCIe), é correto afirmar:",
            options: [
                "É um barramento paralelo de 16 pinos para dados.",
                "É um barramento compartilhado, onde a banda é dividida entre todos os dispositivos.",
                "O PCIe 4.0 oferece aproximadamente 2 GB/s por lane, resultando em cerca de 64 GB/s bidirecional para um slot x16.",
                "Dispositivos PCIe x1 não podem fisicamente ser instalados em slots PCIe x16.",
                "A codificação 8b/10b é utilizada em todas as versões do PCIe até a 5.0."
            ],
            answer: 2, // Letra C
            resolution: "Gabarito: C. PCIe 4.0 tem vazão de 2GB/s por lane. Um slot x16 provê 32GB/s em cada direção (total 64GB/s bidirecional). As versões 3.0+ usam codificação 128b/130b."
        },
        {
            id: 10,
            text: "Questão 10 - Diferentemente do esquema MBR (Master Boot Record), a Tabela de Partição GUID (GPT) utilizada pelo UEFI:",
            options: [
                "Limita o tamanho do disco a 2 TB, mas permite infinitas partições.",
                "Armazena cópias de segurança do cabeçalho da tabela de partição no final do disco, aumentando a resiliência.",
                "Elimina a necessidade de uma partição de sistema EFI (ESP).",
                "É incompatível com sistemas operacionais Windows de 64 bits.",
                "Utiliza endereçamento de 32 bits para os setores lógicos."
            ],
            answer: 1, // Letra B
            resolution: "Gabarito: B. O GPT oferece redundância ao replicar o cabeçalho e a tabela de partição no final da unidade física, permitindo recuperação em caso de corrupção do setor inicial."
        }
    ];

    function loadQuestions() {
        const wrapper = document.getElementById('questions-wrapper');
        questions.forEach((q, index) => {
            const qDiv = document.createElement('div');
            qDiv.className = 'question-block';
            qDiv.id = `q-block-${index}`;

            const qLabel = document.createElement('span');
            qLabel.className = 'question-text';
            qLabel.innerText = q.text;
            qDiv.appendChild(qLabel);

            const optionsUl = document.createElement('ul');
            optionsUl.className = 'options-list';

            q.options.forEach((opt, optIndex) => {
                const li = document.createElement('li');
                li.className = 'option-item';
                li.onclick = () => selectOption(index, optIndex);
                
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = `q${index}`;
                radio.id = `q${index}-opt${optIndex}`;
                radio.value = optIndex;

                const textNode = document.createTextNode(opt);
                
                li.appendChild(radio);
                li.appendChild(textNode);
                optionsUl.appendChild(li);
            });

            qDiv.appendChild(optionsUl);

            const resDiv = document.createElement('div');
            resDiv.className = 'resolution-box';
            resDiv.id = `res-${index}`;
            resDiv.innerHTML = `<h4>Resolução Comentada</h4><p>${q.resolution}</p>`;
            qDiv.appendChild(resDiv);

            wrapper.appendChild(qDiv);
        });
    }

    function selectOption(qIdx, optIdx) {
        const block = document.getElementById(`q-block-${qIdx}`);
        const options = block.querySelectorAll('.option-item');
        options.forEach(opt => opt.classList.remove('selected'));
        options[optIdx].classList.add('selected');
        options[optIdx].querySelector('input').checked = true;
    }

    function calculateResults() {
        let score = 0;
        const form = document.getElementById('quiz-form');

        questions.forEach((q, index) => {
            const selected = form.querySelector(`input[name="q${index}"]:checked`);
            const block = document.getElementById(`q-block-${index}`);
            const options = block.querySelectorAll('.option-item');
            const resolution = document.getElementById(`res-${index}`);

            // Mostrar resolução
            resolution.style.display = 'block';

            if (selected) {
                const val = parseInt(selected.value);
                if (val === q.answer) {
                    score++;
                    options[val].classList.add('correct');
                } else {
                    options[val].classList.add('wrong');
                    options[q.answer].classList.add('correct');
                }
            } else {
                // Se não respondeu, destaca a correta
                options[q.answer].classList.add('correct');
            }
        });

        // Exibir Resumo
        const summary = document.getElementById('results-summary');
        const scoreDisplay = document.getElementById('score-display');
        summary.style.display = 'block';
        scoreDisplay.innerText = `${score} / ${questions.length}`;
        
        // Scroll para o topo
        window.scrollTo({ top: 0, behavior: 'smooth' });

        // Desativar interações
        const allOptions = document.querySelectorAll('.option-item');
        allOptions.forEach(opt => opt.style.pointerEvents = 'none');
        document.getElementById('submit-btn').style.display = 'none';
    }

    window.onload = loadQuestions;
</script>

</body>
</html>